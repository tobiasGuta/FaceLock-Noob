# FaceLock-Noob
**Face-Recon-Noob** is an accessible, entry-level Python tool designed for binary face recognition. It combines robust deep learning models with a straightforward Support Vector Machine (SVM) classifier to identify a single target person.

It works by:

1.  **Detection & Embedding:** Using a pre-trained **Deep Neural Network (DNN)** to detect a face and extract its unique **128-dimensional embedding vector**.

2.  **Classification:** Training an **SVM** on positive (target) and negative (other) embeddings to create a decision boundary.

3.  **Identification:** Classifying a new face as either **'MATCH'** or **'NO MATCH'** based on the confidence score generated by the SVM.

It's an ideal starting project for anyone looking to understand the fundamentals of modern face verification using embeddings and classic machine learning.

The **Face-Recon-Noob** model (an SVM classifier) is trained using **128-dimensional face embeddings** extracted from two distinct image directories: `reference_faces` (Positive class) and `negative_faces` (Negative class).

### 1\. (Data Preparation)

The training process begins by organizing the raw image data into two folders, which define the binary classification problem:

-   **`reference_faces` (Label 1 - POSITIVE):** Contains diverse images (different lighting, angles, expressions) of the **target person** you want the system to recognize.

-   **`negative_faces` (Label 0 - NEGATIVE):** Contains images of **all other people** the system must learn to reject.

### 2\. (Embedding Extraction)

For every image in both directories, the following steps are executed:

1.  **Face Detection:** An OpenCV Caffe DNN model (`res10_300x300_ssd`) locates all faces in the image and returns their bounding box coordinates.

2.  **Face Cropping & Padding:** The largest detected face is cropped with a slight **padding** (10%) to ensure all key facial features are included.

3.  **Feature Vector Generation:** The cropped face is passed through a second pre-trained DNN (Torch/OpenFace, `nn4.small2.v1.t7`). This network generates a unique **128-dimensional vector** (the face embedding) that numerically represents the face's identity.

### 3\. (Training & Scaling)

The collection of all extracted embeddings and their corresponding labels (1 or 0) is used to train the final classifier:

1.  **Scaling:** All 128-dimensional embedding vectors are standardized using a **`StandardScaler`**. This centers the data and scales it to unit variance, which is crucial for maximizing the performance and stability of the SVM.

2.  **SVM Training:** A **Support Vector Machine (`SVC`)** with a linear kernel is fitted to the scaled data. The SVM's job is to find the optimal **hyperplane** (decision boundary) that separates the cluster of **Positive (target)** embeddings from the cluster of **Negative (non-target)** embeddings in the 128-dimensional space.

3.  **Model Persistence:** Both the trained **SVM classifier** (`recognizer.pkl`) and the **`StandardScaler`** (`scaler.pkl`) are saved to disk. This allows the system to load the models instantly for prediction, avoiding the need to retrain the model every time the tool is run.

### 4\. (Setting the Recognition Standard)

After training, the model uses a **probability-based matching rule** for identification:

-   When a new face is presented, the SVM calculates the probability  ($\text{P}(\text{Match})$ that the face belongs to the target person.

-   The face is labeled **"MATCH"** only if this probability exceeds the defined `MATCH_THRESHOLD` (e.g., $0.60$).

# Req

```bash
res10_300x300_ssd_iter_140000.caffemodel
nn4.small2.v1.t7
deploy.prototxt
```
